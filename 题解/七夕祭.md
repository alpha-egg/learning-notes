**题目：** 七夕祭

前缀和

[105. 七夕祭 - AcWing题库](https://www.acwing.com/problem/content/107/)

**题解：**

首先我们可以知道，交换上下行之间相邻的摊位并不会影响每列 cl 感兴趣的摊点数，同理，交换列之间相邻的摊位也不会影响每行 cl 感兴趣的摊点数。所以我们可以分开考虑行和列。

不妨以行为例，我们用数组储存每行 cl 感兴趣的摊位数之和，记为 $r[1] \sim r[N]$  。如果 $T / N$ 是整数，那么就存在解。且如果我们不考虑首尾相连的条件，那么显然最优解是唯一确定的，我们只需要从第一行开始推就好了

- 第一行转移 $|r[1]-\dfrac{T}{N}|$ 个摊位到第二行
- 第二行转移 $|r[1]+r[2]-2*\dfrac{T}{N}|$ 个摊位到第三行

$$
\vdots
$$

- 第 $n$ 行转移 $|\sum_{i=1}^{n} r[i]-i*\dfrac{T}{N}|$  个摊位到第 $i+1$ 行

最终可以得出答案为 

$$
\sum_{i=1}^{N} |\sum_{j=1}^{i} r[j]-j*\dfrac{T}{N}|
$$
令 $v[i]=r[i]-\dfrac{T}{N}$ ，用 $pre[i]$ 表示 $v[i]$ 的前 $i$ 项和，则答案可以表示为

$$
\sum_{i=1}^{N}|pre[i]|
$$

这就是不考虑首尾相连的解题思路。如果首尾相连，问题从链变成了环。**存在一个最优解使得存在两个相邻行之间没有交换**， 因此我们可以将环断成链。假设 第 $k-1$ 行和第 $k$ 行之间没有交换，我们把第 $k$ 行当做起始，则每行的交换数为：

- k: $|pre[k]-pre[k-1]|$
- k+1: $|pre[k+1]-pre[k-1]|$

$$
\vdots
$$

- 1: $pre[1]+pre[N]-pre[k-1]$

$$
\vdots
$$

又因为 $pre[N]=0$ ，所以就相当于求 $\sum_{i=1}^{N}|pre[i]-pre[k]|$ 的最小值，这样问题。我们只需要令 $pre[k]$ 为中位数就可以了。

代码如下（注意要开 long long）：

```c++
#include<bits/stdc++.h>
#define REP(i,a,b) for(int i=(a); i<=(b); i++)
#define PER(i,a,b) for(int i=(a); i>=(b); i--)
using namespace std;
typedef long long ll;

inline ll rd(){
    ll x=0,f=1; char c=getchar(); while(!isdigit(c)){if(c=='-') f=-1; c=getchar();}
    while(isdigit(c)){x=10*x+c-'0'; c=getchar();} return x*f;
}

ll N,M,T;

ll sol(vector<ll> &v){
    ll l=v.size()-1;  //用来表示行数或者列数
    REP(i,1,l) v[i]-=T/l;
    vector<ll> pre(l+1,0);
    REP(i,1,l) pre[i]=pre[i-1]+v[i];  //前缀和
    sort(pre.begin()+1,pre.end());
    ll tmp=pre[(l+1)/2];  //中位数
    ll res=0;
    REP(i,1,l) res+=abs(pre[i]-tmp);
    return res;
}

int main(){
    cin>>N>>M>>T;
    bool fr=!(T%N), fc=!(T%M); //是否能整除
    if(!fr&&!fc){
        cout<<"impossible"<<endl;
        return 0;
    }
    vector<ll> r(N+1,0), c(M+1,0);
    REP(i,1,T){
        int x=rd(),y=rd();
        r[x]++,c[y]++;
    }
    if(fr&&fc) cout<<"both "<<sol(r)+sol(c)<<endl; 
    else if(fr) cout<<"row "<<sol(r)<<endl;
    else if(fc) cout<<"column "<<sol(c)<<endl;
    return 0;
}

```