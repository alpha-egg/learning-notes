**题目：** 火车进出站问题

卡特兰数+高精度

[130. 火车进出栈问题 - AcWing题库](https://www.acwing.com/problem/content/132/)

**题解：**

有 $1 \sim n$ 共 n 个数，可以进行进栈和出栈两个操作，问总共有多少种出栈顺序。

$$
1\leq n\leq 60000
$$

关于这道题，我认为难点有二：

- 如何解决数学问题（如何找到题目的公式）
- 如何解决高精度问题

**数学部分**

首先来解决数学问题，其实如果 n 的数据范围没有这么大的话，这题其实很简单。

因为我们并不在乎出栈的具体方案，只在意出栈方案的总数。我们可以用递推的思路来解决这道题。递推的本质是把一个问题分为几个子问题进行解决。

当数据总量为 N 时，考虑 1 在出栈序列中的位置。如果 1 是第 k 个出栈的，那么出栈的过程可以列为：

- 1 进栈
- $2 \sim k$ 以某种方案进出栈
- 1 出栈
- $k+1 \sim N$ 以某种方式进出栈

也就是说，N个数的进出栈问题，被 1 的位置划分成了 $k-1$ 和 $N-k$ 个数的进出栈问题，递推公式为

$$
S_{N}=\sum_{k=1}^{i} S_{k-1}*S_{N-k} 
$$
于是我们就可以用递推的方法解决，复杂度为 $O(n^{2})$ .

这题其实是卡特兰数的应用，介绍卡特兰数：

- 卡特兰数的递推公式就是 $C_{n}=\sum_{k=1}^{n} C_{k-1}*C_{n-k}$
- 卡特兰数的通项公式为 $C_{n}=\dfrac{C_{2n}^{n}}{n+1}$

我们已经推导了递推公式，现在来推导通项公式：

我们可以把数字进出栈的过程看做一串 **01 序列，1表示进栈，0表示出栈**。一个 01 序列唯一对应一个出栈方案。显然 01 序列的长度为 $2n$ ，0 和 1 都有 n 个。

01 序列的排列总数为 $C_{2n}^{n}$ ，可以理解为从 2n 个空位中选取 n 个位置填 0。但是并不是所有的排列都满足条件，一个合理的 01 序列必须满足：所有前缀 1 的数量大于 0。

假设 01 序列从 2m+1 项开始不满足条件，也就是说前 2m+1 项有 m个 1 和 m+1 个 0。后面的项中有 $n-m-1$ 个 0 ，$n-m$ 个 1，我们把后面的项 0 和 1 互相映射，得到 $n-m-1$ 个 1 ，$n-m$ 个 0，结果得1个由n+1个0和n-1个1组成的2n位数，即一个不合要求的数对应于一个由n+1个0和n-1个1组成的排列。

反过来，任何一个由n+1个0和n-1个1组成的序列，由于0的个数多2个，2n为偶数，故必在某一个奇数位上出现0的累计数超过1的累计数。同样在后面部分0和1互换，使之成为由n个0和n个1组成的2n位数，即n+1个0和n-1个1组成的2n位数必对应一个不符合要求的数。

故不符合要求的数有 $C_{2n}^{n-1}$ 个，所以有 $C_{2n}^{n}-C_{2n}^{n-1}$ 个数满足，即 $\dfrac{C_{2n}^{n}}{n+1}$.

**高精度问题：**

我们已经解决了数学问题，现在对于任意的 n ，我们只要输出 $\dfrac{C_{2n}^{n}}{n+1}$ 就好了。也就是 $\dfrac{2n!}{(n!)(n!)(n+1)}$ 。

当 n 的可以取到 60000 时，显然会爆精度，我们必须用数组来存答案。

为了降低时间复杂度，我们把阶乘分解为**质因数的幂次**进行求解，该过程在筛选质数的同时进行。

代码如下：

```c++
#include<bits/stdc++.h>
#define REP(i,a,b) for(int i=(a); i<=(b); i++)
#define PER(i,a,b) for(int i=(a); i>=(b); i--)
#define PII std::pair<int,int>
using namespace std;
const int M=6e4+50, B=1e9, bb=9;
typedef long long ll;

inline ll rd(){
    ll x=0,f=1; char c=getchar(); while(!isdigit(c)){if(c=='-') f=-1; c=getchar();}
    while(isdigit(c)){x=10*x+c-'0'; c=getchar();} return x*f;
}

int n;
bool notp[M*2];
int a[M];
ll res[6000];
vector<int> pri;

void init(){
    notp[1]=1;
    REP(i,2,2*n){
        if(!notp[i]){
            pri.push_back(i);
            int cnt=pri.size()-1;
            for(int j=2*n/i;j;j/=i) a[cnt]+=j; //加上2n!的幂次
            for(int j=n/i;j;j/=i) a[cnt]-=j*2; //减去 (n!)(n!) 的幂次
            for(int j=n+1;j%i==0;j/=i) a[cnt]--; //n+1
        }
        for(auto p:pri){
            if(p*i>2*n) break;
            notp[p*i]=1;
            if(p%i==0) break;
        }
    }
}

ll qpow(ll a,ll x){
    ll res=1;
    if(a==1||x==0) return res;
    while(x){
        if(x&1) res*=a;
        a*=a;
        x>>=1;
    }
    return res;
}

// 高精度乘法
void mul(ll x){ 
    ll t=0;
    REP(i,1,res[0]){
        res[i]=res[i]*x+t;
        t=res[i]/B;//进位
        res[i]%=B; //res[i]一位存1e9以内的数字，相比于只存一位输出更快
    }
    while(t) res[++res[0]]+=t%B, t/=B; //增加位数
}

//倒序输出+补0
void print(int x,int i=bb){ 
    if(!i) return;
    print(x/10,i-1);
    putchar((x%10)+'0'); // 输出x的末位数字，因为putchar输出的是ASSIC码对应的字符
}

int main(){
    cin>>n;
    init();
    int len=pri.size()-1;
    res[0]=1, res[1]=1; //res[0]存长度，res[1] 初始化为1
    REP(i,0,len) if(a[i]) mul(qpow(pri[i],a[i]));
    printf("%lld",res[res[0]]); //第一位不需要补0
    PER(i,res[0]-1,1) print(res[i]);
    return 0;
}

```